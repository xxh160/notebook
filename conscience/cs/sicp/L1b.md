# lecture 1b

- [lecture 1b](#lecture-1b)
  - [Part 1：代换模型概述](#part-1代换模型概述)
  - [Part 2：线性迭代和线性递归](#part-2线性迭代和线性递归)
  - [Part 3：树形递归](#part-3树形递归)

## Part 1：代换模型概述

在代换模型中，我们是如何对一个组合式求值的？

三步：

1. 对运算符求值，得到过程；
2. 对运算对象求值，得到参数；
3. 将过程应用于运算对象：用求得的参数替换过程中的形式参数，并对新得到的过程体求值。

这种“先求值参数而后应用”的顺序是应用序。与之对偶，“完全展开而后归约”的方式叫做正则序。

它并不是计算机实际的运行方式，但是在接下来几章中它是适用的。

example：

```scheme
(define (sq x) (* x x))
(define (sos x y) (+ (sq x) (sq y)))

(sos 3 4) ->
(+ (sq 3) (sq 4)) ->
(+ (sq 3) (* 4 4)) ->
(+ (sq 3) 16) ->
(+ (* 3 3) 16) ->
(+ 9 16) ->
25
```

皮亚诺算法，定义加法。依赖自增和自减。

## Part 2：线性迭代和线性递归

以皮亚诺算法为例，过程演化的两种典型模式：线性迭代和线性递归：

```scheme
# 线性迭代
(define (+ x y)
    (if (= 0 x)
    y
    (+ (-1+ x) (1+ y))))

# 线性递归
(define (+ x y)
    (if (= 0 x)
    y
    (1+ (+ (-1+ x) y))))
```

用`(+ 3 4)`为例子，推导上述两种过程的演化：

```scheme
# 线性迭代
(+ 3 4) ->
(+ 2 5) ->
(+ 1 6) ->
(+ 0 7) ->
7

# 线性递归
(+ 3 4) ->
(1+ (+ 2 4)) ->
(1+ (1+ (+ 1 4))) ->
(1+ (1+ (1+ (+ 0 4)))) ->
(1+ (1+ (1+ 4))) ->
(1+ (1+ 5)) ->
(1+ 6) ->
7
```

> 基本过程的时空消耗可以认为是 O(1) 的，所以不写在推导过程中

注意，这里的迭代和递归不是定义方式，是计算过程。在定义上，它们都使用了递归的定义方式。

看起来，老师的意思是，迭代和递归的区别在于，每次处理之后的独立性？因为递归必须要有记忆才可以继续下去。

> 书本 p22 23 线性迭代递归的解释  

所以这里的迭代指的就是尾递归？递归必须要等待子函数调用返回，完成最终计算才能够抛弃栈中内存，而尾递归可以在开始进行递归时就抛弃调用者函数的内存。

> 书本 p 23 尾递归的解释

## Part 3：树形递归

以斐波那契数列作为实例讲述属性递归。

> 书本 p 25

汉诺塔的例子。用以讲述递归的计算过程。

递归就是“想当然”。先“耍赖似的”假设子问题已经解决了，然后思考有限的下一步。

简单的判断假设能否成立的方法：问题的规模是否是在缩小，最终归约到某种基础情况。

```scheme
# hanoi
(define (hanoi all from to spare)
    (if (= all 1)
        "done"
        (?? (hanoi (- all 1) from spare to)
            (print "move $all from $from to $to with $spare")
            (hanoi (- all 1) spare from to))))
```

> scheme 里怎么表示两个过程都要执行啊？

这种递归算法的复杂度是指数级，因为父问题依赖于两个问题规模减 1的子问题：`T(n) = 2 * T(n-1) + 1`。
